"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@urql/core");
const path = tslib_1.__importStar(require("node:path"));
const url_1 = require("../../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const generated_1 = require("../../graphql/generated");
const WorkflowRevisionMutation_1 = require("../../graphql/mutations/WorkflowRevisionMutation");
const WorkflowRunMutation_1 = require("../../graphql/mutations/WorkflowRunMutation");
const log_1 = tslib_1.__importStar(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const uploadAccountScopedFileAsync_1 = require("../../project/uploadAccountScopedFileAsync");
const uploadAccountScopedProjectSourceAsync_1 = require("../../project/uploadAccountScopedProjectSourceAsync");
const workflowFile_1 = require("../../utils/workflowFile");
class WorkflowRun extends EasCommand_1.default {
    static description = 'Run an EAS workflow';
    static args = [{ name: 'file', description: 'Path to the workflow file to run' }];
    static flags = {
        ...flags_1.EASNonInteractiveFlag,
    };
    static contextDefinition = {
        ...this.ContextOptions.DynamicProjectConfig,
        ...this.ContextOptions.ProjectDir,
        ...this.ContextOptions.Vcs,
        ...this.ContextOptions.LoggedIn,
    };
    async runAsync() {
        const { flags, args } = await this.parse(WorkflowRun);
        const { getDynamicPrivateProjectConfigAsync, loggedIn: { graphqlClient }, vcsClient, projectDir, } = await this.getContextAsync(WorkflowRun, {
            nonInteractive: flags['non-interactive'],
            withServerSideEnvironment: null,
        });
        let yamlConfig;
        try {
            const workflowFileContents = await workflowFile_1.WorkflowFile.readWorkflowFileContentsAsync({
                projectDir,
                filePath: args.file,
            });
            log_1.default.log(`Using workflow file from ${workflowFileContents.filePath}`);
            yamlConfig = workflowFileContents.yamlConfig;
        }
        catch (err) {
            log_1.default.error('Failed to read workflow file.');
            throw err;
        }
        const { projectId, exp: { slug: projectName }, } = await getDynamicPrivateProjectConfigAsync();
        const account = await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId);
        try {
            await WorkflowRevisionMutation_1.WorkflowRevisionMutation.validateWorkflowYamlConfigAsync(graphqlClient, {
                appId: projectId,
                yamlConfig,
            });
        }
        catch (error) {
            if (error instanceof core_1.CombinedError) {
                workflowFile_1.WorkflowFile.maybePrintWorkflowFileValidationErrors({
                    error,
                    accountName: account.name,
                    projectName,
                });
                throw error;
            }
        }
        let projectArchiveBucketKey;
        let easJsonBucketKey;
        let packageJsonBucketKey;
        try {
            ({ projectArchiveBucketKey } = await (0, uploadAccountScopedProjectSourceAsync_1.uploadAccountScopedProjectSourceAsync)({
                graphqlClient,
                vcsClient,
                accountId: account.id,
            }));
            ({ fileBucketKey: easJsonBucketKey } = await (0, uploadAccountScopedFileAsync_1.uploadAccountScopedFileAsync)({
                graphqlClient,
                accountId: account.id,
                filePath: path.join(projectDir, 'eas.json'),
                maxSizeBytes: 1024 * 1024,
            }));
            ({ fileBucketKey: packageJsonBucketKey } = await (0, uploadAccountScopedFileAsync_1.uploadAccountScopedFileAsync)({
                graphqlClient,
                accountId: account.id,
                filePath: path.join(projectDir, 'package.json'),
                maxSizeBytes: 1024 * 1024,
            }));
        }
        catch (err) {
            log_1.default.error('Failed to upload project sources.');
            throw err;
        }
        try {
            const { id: workflowRunId } = await WorkflowRunMutation_1.WorkflowRunMutation.createWorkflowRunAsync(graphqlClient, {
                appId: projectId,
                workflowRevisionInput: {
                    fileName: path.basename(args.file),
                    yamlConfig,
                },
                workflowRunInput: {
                    projectSource: {
                        type: generated_1.WorkflowProjectSourceType.Gcs,
                        projectArchiveBucketKey,
                        easJsonBucketKey,
                        packageJsonBucketKey,
                    },
                },
            });
            log_1.default.newLine();
            log_1.default.succeed(`Workflow run started successfully. See logs: ${(0, log_1.link)((0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId))}`);
        }
        catch (err) {
            log_1.default.error('Failed to start the workflow with the API.');
            throw err;
        }
    }
}
exports.default = WorkflowRun;
