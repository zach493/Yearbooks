"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowCreate = void 0;
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const promises_1 = tslib_1.__importDefault(require("fs/promises"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const prompts_1 = tslib_1.__importDefault(require("prompts"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const log_1 = tslib_1.__importDefault(require("../../log"));
const workflowFile_1 = require("../../utils/workflowFile");
const DEFAULT_WORKFLOW_NAME = 'workflow.yml';
const HELLO_WORLD_TEMPLATE = `name: Hello World

on:
  push:
    branches: ['*']

jobs:
  hello_world:
    steps:
      - uses: eas/checkout
      - run: echo "Hello, World"
`;
class WorkflowCreate extends EasCommand_1.default {
    static description = 'create a new workflow configuration YAML file';
    static args = [
        {
            name: 'name',
            description: 'Name of the workflow file (must end with .yml or .yaml)',
            required: false,
        },
    ];
    static flags = {
        ...flags_1.EASNonInteractiveFlag,
    };
    static contextDefinition = {
        ...this.ContextOptions.ProjectDir,
    };
    async runAsync() {
        const { args: { name: argFileName }, flags, } = await this.parse(WorkflowCreate);
        const { projectDir } = await this.getContextAsync(WorkflowCreate, {
            nonInteractive: flags['non-interactive'],
        });
        let fileName = argFileName;
        if (!fileName) {
            const response = await (0, prompts_1.default)({
                type: 'text',
                name: 'fileName',
                message: 'What would you like to name your workflow file?',
                initial: DEFAULT_WORKFLOW_NAME,
                validate: value => {
                    try {
                        workflowFile_1.WorkflowFile.validateYamlExtension(value);
                        return true;
                    }
                    catch (error) {
                        return error instanceof Error ? error.message : 'Invalid file name';
                    }
                },
            });
            if (!response.fileName) {
                log_1.default.warn('Workflow creation cancelled.');
                process.exit(0);
            }
            fileName = response.fileName;
        }
        try {
            await this.ensureWorkflowsDirectoryExistsAsync({ projectDir });
            await this.createWorkflowFileAsync({ fileName, projectDir });
        }
        catch (error) {
            log_1.default.error('Failed to create workflow file.');
            throw error;
        }
    }
    async ensureWorkflowsDirectoryExistsAsync({ projectDir, }) {
        try {
            await promises_1.default.access(path_1.default.join(projectDir, '.eas', 'workflows'));
        }
        catch {
            await promises_1.default.mkdir(path_1.default.join(projectDir, '.eas', 'workflows'), { recursive: true });
            log_1.default.withTick(`Created directory ${chalk_1.default.bold(path_1.default.join(projectDir, '.eas', 'workflows'))}`);
        }
    }
    async createWorkflowFileAsync({ fileName, projectDir, }) {
        workflowFile_1.WorkflowFile.validateYamlExtension(fileName);
        const filePath = path_1.default.join(projectDir, '.eas', 'workflows', fileName);
        if (await fs_extra_1.default.pathExists(filePath)) {
            throw new Error(`Workflow file already exists: ${filePath}`);
        }
        await promises_1.default.writeFile(filePath, HELLO_WORLD_TEMPLATE);
        log_1.default.withTick(`Created ${chalk_1.default.bold(filePath)}`);
    }
}
exports.WorkflowCreate = WorkflowCreate;
