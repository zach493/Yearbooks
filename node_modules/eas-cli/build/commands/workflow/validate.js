"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowValidate = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@urql/core");
const YAML = tslib_1.__importStar(require("yaml"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const WorkflowRevisionMutation_1 = require("../../graphql/mutations/WorkflowRevisionMutation");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const workflowFile_1 = require("../../utils/workflowFile");
class WorkflowValidate extends EasCommand_1.default {
    static description = 'validate a workflow configuration yaml file';
    static args = [
        {
            name: 'path',
            description: 'Path to the workflow configuration YAML file (must end with .yml or .yaml)',
            required: true,
        },
    ];
    static flags = {
        ...flags_1.EASNonInteractiveFlag,
    };
    static contextDefinition = {
        ...this.ContextOptions.DynamicProjectConfig,
        ...this.ContextOptions.ProjectDir,
        ...this.ContextOptions.LoggedIn,
    };
    async runAsync() {
        const { args: { path: filePath }, flags, } = await this.parse(WorkflowValidate);
        const { getDynamicPrivateProjectConfigAsync, loggedIn: { graphqlClient }, projectDir, } = await this.getContextAsync(WorkflowValidate, {
            nonInteractive: flags['non-interactive'],
            withServerSideEnvironment: null,
        });
        const { projectId, exp: { slug: projectName }, } = await getDynamicPrivateProjectConfigAsync();
        const account = await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId);
        const spinner = (0, ora_1.ora)().start('Validating the workflow YAML fileâ€¦');
        try {
            const workflowFileContents = await workflowFile_1.WorkflowFile.readWorkflowFileContentsAsync({
                projectDir,
                filePath,
            });
            log_1.default.log(`Using workflow file from ${workflowFileContents.filePath}`);
            const parsedYaml = YAML.parse(workflowFileContents.yamlConfig);
            // Check if the parsed result is empty or null
            if (parsedYaml === null ||
                parsedYaml === undefined ||
                (typeof parsedYaml === 'object' && Object.keys(parsedYaml).length === 0)) {
                throw new Error('YAML file is empty or contains only comments.');
            }
            await WorkflowRevisionMutation_1.WorkflowRevisionMutation.validateWorkflowYamlConfigAsync(graphqlClient, {
                appId: projectId,
                yamlConfig: workflowFileContents.yamlConfig,
            });
            spinner.succeed('Workflow configuration YAML is valid.');
        }
        catch (error) {
            spinner.fail('Workflow configuration YAML is not valid.');
            if (error instanceof YAML.YAMLParseError) {
                log_1.default.error(`YAML syntax error: ${error.message}`);
            }
            else if (error instanceof core_1.CombinedError) {
                workflowFile_1.WorkflowFile.maybePrintWorkflowFileValidationErrors({
                    error,
                    accountName: account.name,
                    projectName,
                });
                throw error;
            }
            else if (error instanceof Error) {
                log_1.default.error(error.message);
            }
            else {
                log_1.default.error(`Unexpected error: ${String(error)}`);
            }
            throw error;
        }
    }
}
exports.WorkflowValidate = WorkflowValidate;
