"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const node_stream_zip_1 = tslib_1.__importDefault(require("node-stream-zip"));
const path_1 = tslib_1.__importDefault(require("path"));
const tar_1 = tslib_1.__importDefault(require("tar"));
const url_1 = require("../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../commandUtils/EasCommand"));
const flags_1 = require("../commandUtils/flags");
const generated_1 = require("../graphql/generated");
const FingerprintMutation_1 = require("../graphql/mutations/FingerprintMutation");
const LocalBuildMutation_1 = require("../graphql/mutations/LocalBuildMutation");
const AppPlatform_1 = require("../graphql/types/AppPlatform");
const log_1 = tslib_1.__importDefault(require("../log"));
const prompts_1 = require("../prompts");
const xcode = tslib_1.__importStar(require("../run/ios/xcode"));
const uploads_1 = require("../uploads");
const progress_1 = require("../utils/progress");
class BuildUpload extends EasCommand_1.default {
    static description = 'upload a local build and generate a sharable link';
    static hidden = true;
    static flags = {
        platform: core_1.Flags.enum({
            char: 'p',
            options: [eas_build_job_1.Platform.IOS, eas_build_job_1.Platform.ANDROID],
        }),
        'build-path': core_1.Flags.string({
            description: 'Path for the local build',
        }),
        fingerprint: core_1.Flags.string({
            description: 'Fingerprint hash of the local build',
        }),
        ...flags_1.EASNonInteractiveFlag,
    };
    static contextDefinition = {
        ...this.ContextOptions.ProjectId,
        ...this.ContextOptions.LoggedIn,
    };
    async runAsync() {
        const { flags } = await this.parse(BuildUpload);
        const { 'build-path': buildPath, fingerprint: manualFingerprintHash } = flags;
        const { projectId, loggedIn: { graphqlClient }, } = await this.getContextAsync(BuildUpload, {
            nonInteractive: false,
        });
        const platform = await this.selectPlatformAsync(flags.platform);
        const localBuildPath = await resolveLocalBuildPathAsync(platform, buildPath);
        const { fingerprintHash: buildFingerprintHash, developmentClient, simulator, } = await extractAppMetadataAsync(localBuildPath, platform);
        let fingerprint = manualFingerprintHash ?? buildFingerprintHash;
        if (fingerprint) {
            if (manualFingerprintHash &&
                buildFingerprintHash &&
                manualFingerprintHash !== buildFingerprintHash) {
                const selectedAnswer = await (0, prompts_1.promptAsync)({
                    name: 'fingerprint',
                    message: `The provided fingerprint hash ${manualFingerprintHash} does not match the fingerprint hash of the build ${buildFingerprintHash}. Which fingerprint do you want to use?`,
                    type: 'select',
                    choices: [
                        { title: manualFingerprintHash, value: manualFingerprintHash },
                        { title: buildFingerprintHash, value: buildFingerprintHash },
                    ],
                });
                fingerprint = String(selectedAnswer.fingerprint);
            }
            await FingerprintMutation_1.FingerprintMutation.createFingerprintAsync(graphqlClient, projectId, {
                hash: fingerprint,
            });
        }
        log_1.default.log('Uploading your app archive to EAS');
        const bucketKey = await uploadAppArchiveAsync(graphqlClient, localBuildPath);
        const build = await LocalBuildMutation_1.LocalBuildMutation.createLocalBuildAsync(graphqlClient, projectId, { platform: (0, AppPlatform_1.toAppPlatform)(platform), simulator }, { type: generated_1.LocalBuildArchiveSourceType.Gcs, bucketKey }, { distribution: generated_1.DistributionType.Internal, fingerprintHash: fingerprint, developmentClient });
        log_1.default.withTick(`Here is a sharable link of your build: ${(0, url_1.getBuildLogsUrl)(build)}`);
    }
    async selectPlatformAsync(platform) {
        if (platform) {
            return platform;
        }
        const { resolvedPlatform } = await (0, prompts_1.promptAsync)({
            type: 'select',
            message: 'Select platform',
            name: 'resolvedPlatform',
            choices: [
                { title: 'Android', value: eas_build_job_1.Platform.ANDROID },
                { title: 'iOS', value: eas_build_job_1.Platform.IOS },
            ],
        });
        return resolvedPlatform;
    }
}
exports.default = BuildUpload;
async function resolveLocalBuildPathAsync(platform, inputBuildPath) {
    const rootDir = process.cwd();
    let applicationArchivePatternOrPath = [];
    if (inputBuildPath) {
        applicationArchivePatternOrPath.push(inputBuildPath);
    }
    else if (platform === eas_build_job_1.Platform.ANDROID) {
        applicationArchivePatternOrPath.push('android/app/build/outputs/**/*.{apk,aab}');
    }
    else {
        const xcworkspacePath = await xcode.resolveXcodeProjectAsync(rootDir);
        const schemes = config_plugins_1.IOSConfig.BuildScheme.getRunnableSchemesFromXcodeproj(rootDir);
        if (xcworkspacePath && schemes.length > 0) {
            for (const scheme of schemes) {
                const buildSettings = await xcode.getXcodeBuildSettingsAsync(xcworkspacePath, scheme.name);
                applicationArchivePatternOrPath = applicationArchivePatternOrPath.concat(buildSettings.map(({ buildSettings }) => `${buildSettings.BUILD_DIR}/**/*.app`));
            }
        }
    }
    let applicationArchives = await findArtifactsAsync({
        rootDir,
        patternOrPathArray: applicationArchivePatternOrPath,
    });
    if (applicationArchives.length === 0 && !inputBuildPath) {
        log_1.default.warn(`No application archives found at ${applicationArchivePatternOrPath}.`);
        const { path } = await (0, prompts_1.promptAsync)({
            type: 'text',
            name: 'path',
            message: 'Provide a path to the application archive:',
            validate: value => (value ? true : 'Path may not be empty.'),
        });
        applicationArchives = await findArtifactsAsync({
            rootDir,
            patternOrPathArray: [path],
        });
    }
    if (applicationArchives.length === 1) {
        return applicationArchives[0];
    }
    if (applicationArchives.length > 1) {
        const { path } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'path',
            message: 'Found multiple application archives. Select one:',
            choices: applicationArchives.map(archivePath => {
                return {
                    title: archivePath,
                    value: archivePath,
                };
            }),
        });
        return path;
    }
    throw new Error(`Found no application archives at ${inputBuildPath}.`);
}
async function findArtifactsAsync({ rootDir, patternOrPathArray, }) {
    const files = [];
    for (const patternOrPath of patternOrPathArray) {
        if (path_1.default.isAbsolute(patternOrPath) && (await fs_extra_1.default.pathExists(patternOrPath))) {
            files.push(patternOrPath);
        }
        else {
            const filesFound = await (0, fast_glob_1.default)(patternOrPath, {
                cwd: rootDir,
                onlyFiles: false,
            });
            files.push(...filesFound);
        }
    }
    return files.map(filePath => {
        // User may provide an absolute path as input in which case
        // fg will return an absolute path.
        if (path_1.default.isAbsolute(filePath)) {
            return filePath;
        }
        // User may also provide a relative path in which case
        // fg will return a path relative to rootDir.
        return path_1.default.join(rootDir, filePath);
    });
}
async function uploadAppArchiveAsync(graphqlClient, path) {
    const fileSize = (await fs_extra_1.default.stat(path)).size;
    const bucketKey = await (0, uploads_1.uploadFileAtPathToGCSAsync)(graphqlClient, generated_1.UploadSessionType.EasShareGcsAppArchive, path, (0, progress_1.createProgressTracker)({
        total: fileSize,
        message: 'Uploading to EAS',
        completedMessage: 'Uploaded to EAS',
    }));
    return bucketKey;
}
async function extractAppMetadataAsync(buildPath, platform) {
    let developmentClient = false;
    let fingerprintHash;
    const simulator = platform === eas_build_job_1.Platform.IOS;
    const basePath = platform === eas_build_job_1.Platform.ANDROID ? 'assets/' : buildPath;
    const fingerprintFilePath = platform === eas_build_job_1.Platform.ANDROID ? 'fingerprint' : 'EXUpdates.bundle/fingerprint';
    const devMenuBundlePath = platform === eas_build_job_1.Platform.ANDROID ? 'EXDevMenuApp.android.js' : 'EXDevMenu.bundle/';
    const buildExtension = path_1.default.extname(buildPath);
    if (['.apk', '.aab'].includes(buildExtension)) {
        const zip = new node_stream_zip_1.default.async({ file: buildPath });
        try {
            developmentClient = Boolean(await zip.entry(path_1.default.join(basePath, devMenuBundlePath)));
            if (await zip.entry(path_1.default.join(basePath, fingerprintFilePath))) {
                fingerprintHash = (await zip.entryData(path_1.default.join(basePath, fingerprintFilePath))).toString('utf-8');
            }
        }
        catch (err) {
            log_1.default.error(`Error reading ${buildExtension}: ${err}`);
        }
        finally {
            await zip.close();
        }
    }
    else if (buildExtension === '.app') {
        developmentClient = await fs_extra_1.default.exists(path_1.default.join(basePath, devMenuBundlePath));
        if (await fs_extra_1.default.exists(path_1.default.join(basePath, fingerprintFilePath))) {
            fingerprintHash = await fs_extra_1.default.readFile(path_1.default.join(basePath, fingerprintFilePath), 'utf8');
        }
    }
    else {
        // Use tar to list files in the archive
        try {
            let fingerprintHashPromise;
            await tar_1.default.list({
                file: buildPath,
                // eslint-disable-next-line async-protect/async-suffix
                onentry: entry => {
                    if (entry.path.endsWith(devMenuBundlePath)) {
                        developmentClient = true;
                    }
                    if (entry.path.endsWith(fingerprintFilePath)) {
                        fingerprintHashPromise = new Promise(async (resolve, reject) => {
                            try {
                                let content = '';
                                for await (const chunk of entry) {
                                    content += chunk.toString('utf8');
                                }
                                resolve(content);
                            }
                            catch (error) {
                                reject(error);
                            }
                        });
                    }
                },
            });
            if (fingerprintHashPromise !== undefined) {
                fingerprintHash = await fingerprintHashPromise;
            }
        }
        catch (err) {
            log_1.default.error(`Error reading ${buildExtension}: ${err}`);
        }
    }
    return {
        developmentClient,
        fingerprintHash,
        simulator,
    };
}
